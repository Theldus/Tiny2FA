/*
 * MIT License
 *
 * Copyright (c) 2018 Davidson Francis <davidsondfgl@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <unistd.h>
#include <fcntl.h>
#include <time.h>

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <sha1.h>
#include <hmac.h>
#include <base32.h>

#include <tiny2fa.h>

/**
 * Generates a secret key by a specified length.
 *
 * @param secret_key Secret-Key pointer, the pointer should have
 * at least 33 bytes (32 + \0).
 */
void t2_generate_secret_key(uint8_t *secret_key)
{
	uint8_t bin_sk[T2_SECRET_KEY_SIZE]; /* Binary secret key. */
	int fd;                             /* File descriptor.    */
	
	fd = open("/dev/urandom", O_RDONLY);
	
	/**
	 * If fail, maybe means that we're not using a Linux system?
	 * anyways, lets use a less secure algorithm...
	 */
	if (fd < 0)
	{
		srand(time(NULL)); 
		for (int i = 0; i < T2_SECRET_KEY_SIZE; i++)
			bin_sk[i] = rand() & 0xFF;
	}
	else
		read(fd, bin_sk, T2_SECRET_KEY_SIZE);

	/* Generates a base32 of the key. */
	base32_encode(bin_sk, T2_SECRET_KEY_SIZE, secret_key, T2_KEY_ENCODED_LENGTH);
	secret_key[T2_KEY_ENCODED_LENGTH] = '\0';

	close(fd);
}

/**
 * Gets the current key based in the base32 secret
 * key passed by parameter and the reference time.
 *
 * @param b32_secret_key Your secret-key, generated by
 * the method @m t2_generate_secret_key.
 *
 * @param tm target time in Unix Time Stamp, if 0, uses
 * the current time.
 *
 * @return Returns the key equivalent for the current time
 * and secret key.
 *
 * @see t2_generate_secret_key
 */
int t2_get_key(const uint8_t *b32_secret_key, uint64_t tm)
{
	uint8_t  sk[T2_SECRET_KEY_SIZE];       /* Original secret key.      */
	uint8_t  hmac[SHA1_DIGEST_LENGTH];     /* HMAC.                     */
	uint8_t  time_padded[T2_TIME_PADDED];  /* Time padded into 8 bytes. */
	uint64_t ctime;                        /* Reference time.           */
	int offset;                            /* Result offset.            */
	int result;                            /* Result.                   */

	/* Time. */
	ctime  = (tm != 0) ? tm : (uint64_t) time(NULL);
	ctime /= T2_KEY_INTERVAL;

	/* Decode secret-key. */
	base32_decode(b32_secret_key, sk, T2_SECRET_KEY_SIZE);

	/* Pad time into a byte array. */
	for (int i = T2_TIME_PADDED - 1; i >= 0; i--)
	{
		time_padded[i] = ctime;
		ctime >>= 8;
	}

	/* Calculates hmac. */
	hmac_sha1(sk, T2_SECRET_KEY_SIZE, time_padded, T2_TIME_PADDED, hmac,
		SHA1_DIGEST_LENGTH);

	/* Get offset and result. */
	offset = hmac[SHA1_DIGEST_LENGTH - 1] & 0xF;
	result = (
			((hmac[offset + 0] & 0x7F) << 24) |
			((hmac[offset + 1] & 0xFF) << 16) |
			((hmac[offset + 2] & 0xFF) <<  8) |
			((hmac[offset + 3] & 0xFF))  );

	result &= 0x7FFFFFFF;
	result %= T2_TOTP_DIGITS;

	/* Clear sk, hmac and time_padded. */
	memset(sk, 0, T2_SECRET_KEY_SIZE);
	memset(hmac, 0, SHA1_DIGEST_LENGTH);
	memset(time_padded, 0, T2_TIME_PADDED);

	return (result);
}

/**
 * Verifies a given base32 secret key through the key provided
 * and a certain window.
 *
 * @param b32_secret_key Your secret-key, generated by
 * the method @m generate_secret_key.
 *
 * @param key User provided key, this is the key to be checked.
 *
 * @param window Validation window. Passing 0 the default value
 * (default = 3) will be used. With default value, will be
 * generated 3 keys: before current time, current time and after.
 * The key will be compared with these n-window keys and if one of
 * them is equal to the key provided the function returns a non
 * negative number and 0 otherwise.
 *
 * @return Returns a non-negative number if the key is valid and
 * 0 otherwise.
 */
int t2_verify_key(const uint8_t *b32_secret_key, int key, int window)
{
	uint64_t ctime;      /* Current time.            */
	int      offset;     /* Start window multiplier. */
	ctime = time(NULL);

	/* Check window size. */
	if (!window)
		window = T2_DEFAULT_WINDOW_SIZE;

	/* Window must be an odd number. */
	if ( !(window & 1) )
		return (-1);

	/* Check through all the keys given the window range. */
	offset = -((window-1)/2);
	for (int i = 0; i < window; i++)
	{
		uint64_t iter_time = ctime + (offset * T2_KEY_INTERVAL);
		if (t2_get_key(b32_secret_key, iter_time) == key)
			return (1);

		offset++;
	}

	return (0);
}
